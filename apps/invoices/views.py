from django.views.generic import ListView, CreateView, UpdateView, DeleteView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse_lazy
from django.shortcuts import redirect, get_object_or_404
from django.db import transaction
from django.contrib import messages
from django.http import HttpResponse
from decimal import Decimal
from .models import Invoice, Invoice_Item
from .forms import InvoiceForm, InvoiceItemFormSet
from .utils import render_to_pdf
from apps.inventory.models import Item

class InvoiceListView(LoginRequiredMixin, ListView):
    model = Invoice
    template_name = 'invoices/invoice_list.html'
    context_object_name = 'invoices'
    paginate_by = 20

    def get_queryset(self):
        queryset = Invoice.objects.filter(user=self.request.user).select_related('customer', 'user')
        
        # Get filter parameters
        status = self.request.GET.get('status')
        customer_id = self.request.GET.get('customer')
        date_from = self.request.GET.get('date_from')
        date_to = self.request.GET.get('date_to')
        search = self.request.GET.get('search')
        
        # Apply filters
        if status:
            queryset = queryset.filter(status=status)
        
        if customer_id:
            queryset = queryset.filter(customer_id=customer_id)
        
        if date_from:
            queryset = queryset.filter(issue_date__gte=date_from)
        
        if date_to:
            queryset = queryset.filter(issue_date__lte=date_to)
        
        if search:
            from django.db.models import Q
            queryset = queryset.filter(
                Q(invoice_number__icontains=search) |
                Q(customer__customer_name__icontains=search)
            )
        
        return queryset.order_by('-created_at')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        from apps.customers.models import Customer
        context['customers'] = Customer.objects.filter(user=self.request.user).order_by('customer_name')
        context['total_invoices'] = self.get_queryset().count()
        return context

class InvoiceCreateView(LoginRequiredMixin, CreateView):
    model = Invoice
    form_class = InvoiceForm
    template_name = 'invoices/invoice_form.html'
    success_url = reverse_lazy('invoice_list')

    def get_context_data(self, **kwargs):
        data = super().get_context_data(**kwargs)
        if self.request.POST:
            data['items'] = InvoiceItemFormSet(self.request.POST)
        else:
            data['items'] = InvoiceItemFormSet()
        return data

    def form_valid(self, form):
        context = self.get_context_data()
        items = context['items']
        
        with transaction.atomic():
            form.instance.user = self.request.user
            # Invoice number will be auto-generated by model's save method
            
            self.object = form.save()
            
            if items.is_valid():
                items.instance = self.object
                # Save with commit=False to calculate totals BEFORE saving to database
                invoice_items = items.save(commit=False)
                
                # Calculate totals
                subtotal = 0
                tax_total = 0
                
                for item in invoice_items:
                    # Calculate item total BEFORE saving
                    item_subtotal = item.quantity * item.price
                    item_tax = item_subtotal * (item.tax_rate / 100)
                    item.total = item_subtotal + item_tax
                    item.invoice = self.object  # Ensure invoice is set
                    item.save()  # Now save with total calculated
                    
                    subtotal += item_subtotal
                    tax_total += item_tax
                
                # Update invoice totals
                self.object.subtotal = subtotal
                self.object.tax_total = tax_total
                self.object.total_amount = subtotal + tax_total - Decimal(str(self.object.discount))
                self.object.save()
                
                # Reduce inventory only if invoice is paid (not draft)
                if self.object.status == 'paid':
                    for item in invoice_items:
                        inventory_item = item.item
                        inventory_item.available_qty -= item.quantity
                        inventory_item.save()
                
                messages.success(self.request, f'Invoice {self.object.invoice_number} created successfully!')
                return redirect(self.object.get_absolute_url())
            else:
                return self.form_invalid(form)

class InvoiceUpdateView(LoginRequiredMixin, UpdateView):
    model = Invoice
    form_class = InvoiceForm
    template_name = 'invoices/invoice_form.html'
    success_url = reverse_lazy('invoice_list')
    pk_url_kwarg = 'invoice_id'

    def get_queryset(self):
        return Invoice.objects.filter(user=self.request.user)
    
    def dispatch(self, request, *args, **kwargs):
        """Prevent editing finalized invoices"""
        invoice = self.get_object()
        if not invoice.is_editable():
            messages.error(request, f'Invoice {invoice.invoice_number} cannot be edited (status: {invoice.get_status_display()}).')
            return redirect('invoice_detail', invoice_id=invoice.invoice_id)
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        data = super().get_context_data(**kwargs)
        if self.request.POST:
            data['items'] = InvoiceItemFormSet(self.request.POST, instance=self.object)
        else:
            data['items'] = InvoiceItemFormSet(instance=self.object)
        return data

    def form_valid(self, form):
        context = self.get_context_data()
        items = context['items']
        
        with transaction.atomic():
            # Track old status
            old_status = Invoice.objects.get(pk=self.object.pk).status
            
            self.object = form.save()
            
            if items.is_valid():
                # If changing from draft/pending to paid, reduce inventory
                if old_status in ['draft', 'pending'] and self.object.status == 'paid':
                    for item in self.object.items.all():
                        inventory_item = item.item
                        inventory_item.available_qty -= item.quantity
                        inventory_item.save()
                
                # If changing from paid back to draft/pending, restore inventory
                elif old_status == 'paid' and self.object.status in ['draft', 'pending']:
                    for item in self.object.items.all():
                        inventory_item = item.item
                        inventory_item.available_qty += item.quantity
                        inventory_item.save()
                
                items.instance = self.object
                # Save with commit=False for updates too
                invoice_items = items.save(commit=False)
                
                # Recalculate totals
                subtotal = 0
                tax_total = 0
                
                for item in invoice_items:
                    item_subtotal = item.quantity * item.price
                    item_tax = item_subtotal * (item.tax_rate / 100)
                    item.total = item_subtotal + item_tax
                    item.invoice = self.object
                    item.save()
                    
                    subtotal += item_subtotal
                    tax_total += item_tax
                
                self.object.subtotal = subtotal
                self.object.tax_total = tax_total
                self.object.total_amount = subtotal + tax_total - Decimal(str(self.object.discount))
                self.object.save()
                
                messages.success(self.request, f'Invoice {self.object.invoice_number} updated successfully!')
                return redirect(self.object.get_absolute_url())
            else:
                return self.form_invalid(form)

class InvoiceDetailView(LoginRequiredMixin, DetailView):
    model = Invoice
    template_name = 'invoices/invoice_detail.html'
    context_object_name = 'invoice'
    pk_url_kwarg = 'invoice_id'

    def get_queryset(self):
        return Invoice.objects.filter(user=self.request.user)

class InvoicePDFView(LoginRequiredMixin, DetailView):
    model = Invoice
    template_name = 'invoices/invoice_pdf.html'
    context_object_name = 'invoice'
    pk_url_kwarg = 'invoice_id'

    def get_queryset(self):
        return Invoice.objects.filter(user=self.request.user)

    def render_to_response(self, context, **response_kwargs):
        pdf = render_to_pdf(self.template_name, context)
        if pdf:
            response = HttpResponse(pdf, content_type='application/pdf')
            filename = f"Invoice_{self.object.invoice_number}.pdf"
            content = f"inline; filename={filename}"
            response['Content-Disposition'] = content
            return response
        return HttpResponse("Not found")
